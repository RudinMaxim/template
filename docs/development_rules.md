# Руководство по проекту

## 1. Архитектура

Проект следует принципам Feature-Sliced Design (FSD). Основные слои:

- `app`: страница приложения
- `entities`: бизнес-сущности
- `features`: бизнес-функции приложения
- `shared`: переиспользуемые компоненты и утилиты
- `style`: глобальные стили
- `widgets`: компоненты, которые не являются частью бизнес-функций

> Прочитайте [официальную документацию](https://feature-sliced.design/docs/get-started/overview) для более подробной информации.

## 2. Управление элементами проекта

### Создание нового элемента

Для создания нового элемента в проекте используйте следующую команду:

```bash
npm run create:element
```

После запуска команды следуйте инструкциям в интерактивном режиме:

1. Выберите тип компонента (entity, feature, ui, widget, page, api).
2. Введите имя компонента (для UI и widget) или маршрут (для page и api).
3. Если вы создаете UI компонент или виджет, вам будет предложено выбрать, нужен ли хук для компонента.

Скрипт автоматически создаст необходимые файлы и структуру папок для выбранного элемента.

### Получение списка элементов

Чтобы получить список существующих элементов, используйте команду:

```bash
npm run lister:element
```

Эта команда отобразит список всех созданных элементов в проекте, сгруппированных по типам.

### Удаление элемента

Для удаления существующего элемента используйте команду:

```bash
npm run remover:element
```

Следуйте инструкциям в интерактивном режиме, чтобы выбрать элемент для удаления. Будьте осторожны, так как эта операция необратима.

### Шпаргалка: Куда добавлять сущности

При создании новых элементов в проекте следуйте этим рекомендациям:

1. **Entities (сущности)**:

   - Путь: `src/entities`
   - Используйте для базовых бизнес-сущностей (например, User, Product, Order).
   - Содержит модель данных, компоненты для отображения, связанные хуки.

2. **Features (фичи)**:

   - Путь: `src/features`
   - Используйте для функциональных возможностей, которые могут быть переиспользованы в разных частях приложения (например, AuthForm, ProductSearch).
   - Содержит компоненты, логику и состояние, специфичные для конкретной функциональности.

3. **UI компоненты**:

   - Путь: `src/shared/ui`
   - Используйте для переиспользуемых UI компонентов (например, Button, Input, Modal).
   - Не должны содержать бизнес-логику.

4. **Widgets (виджеты)**:

   - Путь: `src/widgets`
   - Используйте для более крупных составных компонентов, которые могут включать в себя несколько entities и features (например, UserProfileWidget, ShoppingCartWidget).

5. **Pages (страницы)**:

   - Путь: `src/app/(pages)`
   - Используйте для создания страниц приложения.
   - Обычно композиция из widgets, features и entities.

6. **API routes**:
   - Путь: `src/app/api`
   - Используйте для создания API эндпоинтов в Next.js приложении.

Помните, что структура проекта должна способствовать повторному использованию кода и облегчать навигацию. При создании нового элемента всегда задавайте себе вопрос: "Где этот элемент будет использоваться и насколько он переиспользуем?"

## 3. Руководство по стилям проекта

### Обзор

В нашем проекте мы используем SCSS в сочетании с методологией BEM для создания масштабируемой и поддерживаемой системы стилей. Глобальные стили служат основой для всего проекта, обеспечивая консистентность и облегчая разработку.

> Прочитай тему [SCSS](https://sass-lang.com/documentation/syntax) и [BEM](https://en.bem.info/methodology/quick-start/) для лучшего понимания.

### 2. Структура файлов

```
styles/
├── _variables.scss   # Глобальные переменные
├── _colors.scss      # Цветовая палитра
├── _mixins.scss      # Миксины
├── _functions.scss   # Функции
├── _reset.scss       # Сброс стилей
├── _typography.scss  # Типографика
├── _global.scss      # Глобальные стили
└── common.scss       # Основной файл, импортирующий все остальные
```

### Правила BEM (Block Element Modifier)

#### Правила именования

- Блок: `.block`
- Элемент: `.block__element`
- Модификатор: `.block--modifier` или `.block__element--modifier`

#### Пример SCSS с BEM

```scss
.button {
  padding: $spacing-sm $spacing-md;
  background-color: $color-primary;
  color: $color-white;

  &__icon {
    margin-right: $spacing-xs;
  }

  &--large {
    padding: $spacing-md $spacing-lg;
    font-size: $font-size-lg;
  }
}
```

#### Медиа-запросы

Используйте миксин `breakpoint` для создания адаптивных стилей:

```scss
.container {
  width: 100%;

  @include breakpoint(md) {
    max-width: 720px;
  }

  @include breakpoint(lg) {
    max-width: 960px;
  }
}
```

#### Адаптивность

Используйте миксин `responsive` для создания адаптивных стилей:

```scss
@include responsive(margin, 10px, 20px, 30px, null, 50px);
```

#### Лучшие практики

- Избегайте глубокой вложенности селекторов (не более 3 уровней).
- Используйте переменные для всех повторяющихся значений.
- Комментируйте сложные части кода.
- Группируйте медиа-запросы в конце селектора.
- Используйте миксины для повторяющихся групп свойств.

#### Производительность

- Избегайте излишне специфичных селекторов.
- Минимизируйте использование `!important`.
- Оптимизируйте и минифицируйте CSS перед продакшном.

Следуя этим правилам и рекомендациям, мы обеспечим консистентность, масштабируемость и удобство поддержки стилей в нашем проекте.

## 3. Именование

- Компоненты: PascalCase (например, `UserProfile.tsx`)
- Файлы утилит: camelCase (например, `formatDate.ts`)
- Константы: UPPER_SNAKE_CASE (например, `MAX_ITEMS`)
- CSS классы: kebab-case для BEM (например, `user-profile__avatar`)

## Пакеты проекта и их назначение

Проект использует следующие основные пакеты и инструменты:

### Основные зависимости

1. **Next.js (v14.2.15)**: Фреймворк для React приложений с серверным рендерингом и генерацией статических сайтов.

   - Используется для создания оптимизированных React приложений.

2. **React (v18) и React DOM (v18)**: Библиотека для создания пользовательских интерфейсов.

3. **Axios (v1.7.7)**: Библиотека для выполнения HTTP-запросов.

   - Используется для взаимодействия с API.

4. **GSAP (v3.12.5)**: Библиотека для создания анимаций.

   - Применяется для реализации сложных анимаций в проекте.

5. **Zod (v3.23.8)**: Библиотека для валидации схем данных.
   - Используется для проверки и валидации данных.

### Инструменты разработки

1. **TypeScript (v5)**: Типизированный суперсет JavaScript.

   - Обеспечивает статическую типизацию для улучшения качества кода.

2. **ESLint (v8.57.1)**: Инструмент для статического анализа кода.

   - Конфигурация включает плагины для React, TypeScript и импортов.

3. **Prettier (v3.3.3)**: Инструмент для автоматического форматирования кода.

4. **Stylelint (v16.9.0)**: Линтер для CSS/SCSS.

   - Используется вместе с конфигурациями для SCSS и интеграции с Prettier.

5. **Jest (v29.4.3)** и **React Testing Library**: Фреймворк для тестирования.

   - Используется для написания и запуска unit и integration тестов.

6. **Husky (v8.0.3)** и **lint-staged (v13.1.2)**: Инструменты для настройки Git-хуков.

   - Обеспечивают автоматический запуск линтеров и форматирование кода перед коммитом.

7. **SASS (v1.79.4)**: Препроцессор CSS.
   - Используется для написания более структурированных и поддерживаемых стилей.

### Скрипты

- `npm run dev`: Запуск проекта в режиме разработки.
- `npm run build`: Сборка проекта для производства.
- `npm run start`: Запуск собранного проекта.
- `npm run lint`: Проверка кода с помощью ESLint и Stylelint.
- `npm run lint:fix`: Автоматическое исправление проблем, найденных ESLint.
- `npm run test`: Запуск тестов с помощью Jest.
- `npm run format`: Форматирование кода с помощью Prettier.
- `npm run create:element`, `npm run lister:element`, `npm run remover:element`: Скрипты для управления элементами проекта.
- `npm run git-flow`: Запуск скрипта для автоматизации Git Flow.

### Рекомендации по использованию

1. Перед началом работы убедитесь, что все зависимости установлены: `npm install`
2. Используйте `npm run dev` для локальной разработки.
3. Перед коммитом код автоматически проверяется и форматируется благодаря Husky и lint-staged.
4. Пишите тесты для новых функций и используйте `npm run test` для их запуска.
5. Используйте скрипты `create:element`, `lister:element` и `remover:element` для управления компонентами проекта.
6. Для работы с ветками и коммитами используйте скрипт `git-flow`.
